% -*- latex -*-

\documentclass[twocolumn]{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{fancyvrb}
\usepackage{ifthen}
\usepackage{cite}
\usepackage{subfig}
\usepackage{xspace}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{verbatim}

\usepackage{color}
\definecolor{yellow}{rgb}{1,1,0}
\definecolor{black}{rgb}{0,0,0}
\definecolor{ltcyan}{rgb}{.75,1,1}
\definecolor{red}{rgb}{1,0,0}

% Cite commands I use to abstract away the different ways to reference an
% entry in the bibliography (superscripts, numbers, dates, or author
% abbreviations).  \scite is a short cite that is used immediately after
% when the authors are mentioned.  \lcite is a full citation that is used
% anywhere.  Both should be used right next to the text being cited without
% any spacing.
\newcommand*{\lcite}[1]{~\cite{#1}}
\newcommand*{\scite}[1]{~\cite{#1}}

\newcommand{\etal}{et al.}

\newcommand*{\keyterm}[1]{\emph{#1}}

\newcommand{\fix}[1]{{\color{red}\textsc{[#1]}}}

% Avoid putting figures on their own page.
\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.95}
\renewcommand{\bottomfraction}{0.95}

% Make sure this is big enough so that only big figures end up on their own
% page but small enough so that if a figure does have to be on its own
% page, it won't push everything to the bottom because it's not big enough
% to have its own page.
\renewcommand{\floatpagefraction}{.75}

\newenvironment{packed_itemize}{
\begin{itemize}
  \setlength{\topsep}{0pt}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \setlength{\partopsep}{0pt}
}{\end{itemize}}

\title{Flexible Analysis Software for Emerging Architectures}

\author{Kenneth~Moreland and others}

\begin{document}

\sloppy

\maketitle

\begin{abstract}
  We are on the threshold of a transformative change in the basic
  architecture of high performance computing.  The use of accelerator
  processors, characterized by large core counts, shared but asymetric
  memory, and heavy thread loading, is quickly becoming the norm in high
  performance computing.  These accelerators represent siginficant
  challenges in updating our existing base of software.  An intrinsic
  problem with this transition is a fundamental programming shift from
  message passing processes to much more fine thread scheduling with memory
  sharing.  Another problem is the lack of stability in accelerator
  implementation; processor and compiler technology is currently changing
  rapidly.  In this paper we describe our approach to address these two
  immediate problems with respect to scientific analysis and visualization
  algorithms.  Our approach to accelerator programming forms the basis of
  the Dax toolkit, a framework to build data analysis and visualization
  algorithms applicable to exascale computing.
\end{abstract}

\section{Introduction}
\label{sec:Introduction}

Whereas supercomputers throughout the terascale era were almost
unilaterally built from general purpose CPU processors on distributed
memory nodes with a message passing interface, with petascale computing we
are seeing the emerging use of accelerators to meet the execution and
computation requirements of modern leadership-class facilities.

\section{Previous Work}

Generic programming.

Functor-based exection.

Thrust.

Parallel visualization.

Dax.

\section{General Algorithmic Approach}

\section{Device Adapter}

\section{Generic Array Handle}

\end{document}
